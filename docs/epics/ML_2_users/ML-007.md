***

## 1) Цель

**Бизнес-цель:**  
Автоматически регистрировать каждого первого посетителя сайта как гостевого пользователя, чтобы обеспечить непрерывный трекинг по userId между сессиями и на любых устройствах.

**Технически:**  
При первом обращении с фронта бекенд создает:
- пользователя с role=GUEST и status=UNREGISTERED
- userSession с привязкой к sessionId и userDevice
- userDevice с отпечатком устройства
- cart и wishlist, связанные с этим пользователем

**Идемпотентность:**  
При повторных обращениях:
- повторно использовать уже имеющегося пользователя, устройство, сессию, если они найдены; создавать только недостающие сущности
- во всех случаях возвращать на UI полный набор идентификаторов: userId, userSessionId, userDeviceId, cartId, wishlistId

***

## 2) REST API, требования, валидация

**Точка входа:**  
POST /api/v1/users/guest

**Назначение:**  
Создание или "реанимация" гостевого пользователя по sessionId и информации об устройстве; возвращаются ID для трекинга.

**Заголовки:**
- X-Request-Id: опционально; генерируется, если нет; для трейсинга.
- Content-Type: application/json
- X-Forwarded-For или Remote-Addr: автоматом извлекается бекендом как ipAddress (если доступно)

**Тело запроса (UserCreateRequestApiDto):**
- sessionId: UUID (обязательное)
- deviceType: enum [MOBILE, TABLET, DESKTOP, BOT, OTHER] (обязательное)
- deviceUuid: UUID (опционально, но рекомендовано; уникально, если присутствует)
- deviceName: string[0..100] (опционально)
- osVersion: string[0..50] (опционально)
- browserName: string[0..50] (опционально)
- browserVersion: string[0..50] (опционально)
- screenWidth: int[>0] (опционально)
- screenHeight: int[>0] (опционально)
- screenDensity: decimal(4,2)[>0] (опционально)

**Валидация:**
- sessionId: обязателен, валидный UUID
- deviceType: обязателен, валидный enum
- deviceUuid (если есть) — UUID
- строки не превышают лимиты длины, числовые значения положительные
- если отсутствует sessionId или deviceType — 400 Bad Request
- на повторный sessionId — не создавать дубликаты, возвращать ранее созданное
- идемпотентность: если sessionId уже был — вернуть существующую связку

**Ответы:**
- 201 Created: { userId, userSessionId, userDeviceId, cartId, wishlistId }
- 200 OK: Аналогично, если сущности были созданы ранее или уже есть
- 400: ошибки валидации, неверные enum/UUID
- 409: конфликт уникальности deviceUuid (случай крайне редок, при корректной реализации идемпотентности избегается)
- 500: внутренняя ошибка (со стандартной схемой ошибки и traceId)

**Безопасность:**
- Публичная ручка, без авторизации; лимитировать частоту по IP/device для защиты от злоупотреблений
- В запросе нет персональных данных (PII); не писать device токены в логи без маскирования

**Идемпотентность/повторы:**
- Главный ключ идемпотентности — sessionId
- Можно поддержать X-Idempotency-Key (UUID) для избыточных защит
- sessionId уже существует: возвращаем ассоциации, новую запись НЕ создаем

***

## 3) Дизайн таблиц БД

**users**
- id: bigint PK (sequence)
- first_name, last_name, middle_name: varchar(50) nullable
- birth_date: date nullable
- role: enum [GUEST, CUSTOMER, ADMIN и др.], not null, default GUEST
- status: enum [UNREGISTERED, REGISTERED, BANNED и др.], not null, default UNREGISTERED
- avatar_url: text nullable
- created_at: timestamp not null default now()
- updated_at: timestamp
- Индексы: idx_users_role_status (role, status), idx_users_created_at (created_at)

**user_devices**
- id: bigint PK (sequence)
- user_id: bigint FK -> users(id) not null
- device_type: enum not null
- device_uuid: uuid UNIQUE nullable (уникальное, если есть)
- device_name: varchar(100)
- os_version, browser_name, browser_version: varchar(50)
- screen_width, screen_height: int
- screen_density: numeric(4,2)
- push_token: text nullable
- last_seen_at: timestamp
- created_at: timestamp not null default now()
- Индексы: idx_user_devices_user_id, idx_user_devices_type

**user_session**
- id: bigint PK (sequence)
- session_id: uuid, not null, UNIQUE
- user_id: bigint FK -> users(id) not null
- user_device_id: bigint FK -> user_devices(id)
- ip_address: inet nullable
- created_at: timestamp not null default now()
- last_activity_at: timestamp not null
- expires_at: timestamp not null
- status: enum [ACTIVE, EXPIRED, INVALIDATED] default ACTIVE
- Индексы: idx_user_session_user_id, idx_user_session_device_id, idx_user_session_expires_at

**carts**
- id: bigint PK
- user_id: bigint FK -> users(id) UNIQUE (одна активная корзина на пользователя)
- status: enum [ACTIVE, CHECKED_OUT, ABANDONED] default ACTIVE
- created_at: timestamp not null default now()
- updated_at: timestamp

**wishlists**
- id: bigint PK
- user_id: bigint FK -> users(id) UNIQUE
- created_at: timestamp not null default now()

**Примечания:**
- Уникальные индексы (user_session.session_id, user_devices.device_uuid) обеспечивают идемпотентность и предотвращают дубликаты даже при гонках
- Частичные уникальные индексы на случай soft delete в будущем
- Не использовать жадную подгрузку сущностей — только по FK/id

***

## 4) Псевдокод (общая логика)

**Контроллер**
```
POST /api/v1/users/guest
- Валидация запроса
- Маппинг DTO в domain
- response = userCreateFacadeService.createGuestUser(dto)
- Вернуть 201/200 с response
```

**Фасад (UserCreateFacadeService):**
```
@Transactional
UserCreateResponseDto = userCreateService.createUser(dto) // userId, userSessionId, userDeviceId
cartId = cartCreateService.createCartIfAbsent(userId)
wishlistId = wishlistCreateService.createWishlistIfAbsent(userId)
Вернуть aggregate(userId, userSessionId, userDeviceId, cartId, wishlistId)
```

**Домен (UserCreateService):**
```
1. Проверить по sessionId — если найден:
    - вернуть существующего user, userSession, userDevice (создать device если fp изменился)
2. Если sessionId нет — проверить deviceUuid:
    - если найден device, создать новую сессию (userSession) для user, связать с устройством
3. Если deviceUuid тоже нет — создать совершенно нового user c role=GUEST status=UNREGISTERED, userDevice, userSession
```

**Хелперы:**
- resolveOrCreateDeviceForUser — если deviceUuid отсутствует, искать по отпечатку (по возможности)
- ensureSessionDeviceLink — если у session нет userDevice и device != null, привязать

**Гарантии идемпотентности:**
- Каждая вставка session проверяет uniqueness; если конфликт — читать существующую
- Так же для deviceUuid

***

## 5) Диаграммы последовательности (словесно)

**A) Первый визит (нет ни session, ни device)**
- UI → Controller: POST /users/guest {sessionId, deviceInfo}
- Controller → Facade: createGuestUser(dto)
- Facade → UserCreateService: createUser(dto)
- UserCreateService: не найден session → не найден device → создать user, device, session
- Facade: создать cart, wishlist (если нет)
- Response: все новые/созданные ID

**B) Повторный визит по тому же sessionId**
- Найден session → возвращается ранее созданный user, session, deviceId
- cart/wishlist создаются, если их нет

**C) Новый sessionId, но знакомый deviceUuid**
- Найден device → создать новую session для user, привязать device
- cart/wishlist — если нет

***

## 6) Мониторинг и алерты

**Метрики (через Micrometer/OpenTelemetry):**
- Кол-во запросов, latency p95/p99, error_rate эндпоинта
- user.guest.create.attempts / user.guest.create.success / user.guest.create.idempotent_hit / user.guest.create.conflict_resolved
- session.create.success/conflict, active_sessions
- device.create.success/reused
- cart/wishlist.create.success/fail
- ДБ: latency запросов, использование пула, N+1
- Кэш (если есть): hit/miss

**Логирование:**
- Всегда писать correlationId (X-Request-Id), sessionId в MDC
- INFO — только ключевые события (создан userId/sessionId/deviceId, привязки, повторы)
- Ошибки всегда с деталями: exception, code, correlationId (без PII)

**Алерты:**
- error_rate >2% — критический алерт
- всплеск conflicts по уникальным полям — исследовать
- latency p95 >500ms 10 минут — алерт
- пул коннектов к ДБ >80% 5 мин — алерт
- неожиданные провалы в user.guest.create.success при нормальном трафике — алерт

**Дашборды:**
- Воронка: попытки → успехи → создание cart/wishlist
- Разрез по deviceType
- Динамика конфликтов/повторов

***

## 7) Риски и потенциальные проблемы

- **Дубликаты:** Параллельные запросы с одним sessionId/deviceUuid гоняют, но ловятся уникальными constraints + удерживанием транзакций/ретраями
- **Перемешивание пользователей:** На шаред-устройствах, при чистке cookies может создаваться несколько guest для одного user (аналитики должны быть к этому готовы)
- **Истечение/чистка сессий:** Необходимо контролировать экспирацию
- **Дубликаты cart/wishlist:** Enforce unique(user_id) и createIfAbsent семантику
- **Нет deviceUuid:** Если невозможно получить deviceUuid (браузер), используем только sessionId для идемпотентности
- **Злоупотребления (боты):** Public endpoint, лимитировать по IP/device, валидировать поле, отбрасывать подозрительные payload
- **GDPR/consent:** Без PII, политики удаления и не-персонализированности до регистрации
- **Транзакции:** @Transactional на фасаде работает только если все сервисы в одном datasource/менеджере транзакций
- **Часовой пояс:** Все временные поля — UTC

***

## 8) Безопасность и ограничения

- **Минимизация данных:** не собирать лишние поля, не логировать PII, device-токены — только маскировано
- **Rate Limiting:** по IP/deviceUuid/sessionId — не более 60/мин на уникальное значение
- **Валидация:** жесткая enum/properties, ограничение screenWidth/screenHeight
- **Безопасность:** нет side-effect-ов, нельзя указать userId в ручке напрямую
- **Идемпотентность:** через уникальные ключи и корректный retry-on-conflict
- **TTL и чистка:** session expire через 24ч, гостевые пользователей/devices — не хранить больше 90дней; регулярный cron очистки
- **Наблюдаемость:** correlationId обязателен всегда (если нет — генерировать)

***

## 9) Критерии приёмки

**Функциональные:**
- При первом запросе создается user (GUEST/UNREGISTERED), device (если есть deviceUuid), session, cart, wishlist
- На повтор — возвращаются те же ID, ничего не дублируется
- Корректные коды статуса: 201 для новых, 200 для idempotency
- Не возникает дубликатов/конфликтов по БД
- Любая ошибка — понятный ответ с traceId

**Технические:**
- p95 latency ≤ 500ms
- Нет "осиротевших" cart/wishlist/session; любой сбой откатывается транзакцией

**Безопасность:**
- Все поля валидируются и минимально необходимы
- Нет персональных данных, ничего лишнего в логах

**Мониторинг:**
- Вся активность протоколируется с correlationId
- Отчетливый сплит по статусам, причинам конфликтов и трейсам

**Интеграция:**
- Структура сервисов и классов — в точности по слоям (Controller → Facade → Service → ...), все через мапперы/DTO
- Каждая сущность обслуживается своим модулем
- Нет прямых межмодульных обращений

***