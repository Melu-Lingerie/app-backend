**ML-008** - Как пользователь, я хочу добавлять/изменять количесво/удалять товары в корзине

## Постановка задачи для бэкенд-разработчика (без SQL функций)
**Тема:** «Добавление товаров в корзину с бизнес-логикой на backend»

### 1. Цель
Обеспечить авторизованным пользователям возможность добавления товаров в персональную корзину с выбором конкретных вариантов (цвет/размер), 
управлением количества, фиксацией актуальных цен и валидацией доступности товарных позиций через бизнес-логику на уровне приложения.

### 2. Требования к API

| Параметр                           | Описание                                              |
|------------------------------------|-------------------------------------------------------|
| `POST     /api/v1/cart/items`      | Добавление товара в корзину                           |
| `PUT      /api/v1/cart/items/{id}` | Обновление количества товара                          |
| `DELETE   /api/v1/cart/items/{id}` | Удаление товара из корзины                            |
| `GET      /api/v1/cart`            | Получение содержимого корзины                         |
| `DELETE   /api/v1/cart`            | Очистка всей корзины                                  |
| Headers                            | `X-User-Id` обязательный                              |
| Время ответа                       | p95 ≤ 200 ms (увеличено из-за множественных запросов) |
| Rate limit                         | 100 req/min/user для операций с корзиной              |

### 3. SQL запросы

```sql
-- Поиск активной корзины пользователя
SELECT id FROM carts 
WHERE user_id = ? AND is_active = TRUE;

-- Создание новой корзины
INSERT INTO carts (user_id) VALUES (?) RETURNING id;

-- Проверка доступности варианта товара
SELECT pv.stock_quantity, p.is_active, pv.is_available
FROM product_variants pv
JOIN products p ON p.id = pv.product_id
WHERE pv.id = ? AND pv.product_id = ?;

-- Получение актуальной цены
SELECT id, price 
FROM product_prices 
WHERE product_id = ? 
ORDER BY updated_at DESC 
LIMIT 1;

-- Поиск существующего товара в корзине
SELECT id, quantity 
FROM cart_items 
WHERE cart_id = ? AND product_id = ? AND variant_id = ?;

-- Добавление нового товара в корзину
INSERT INTO cart_items (cart_id, product_id, variant_id, quantity, product_price_id)
VALUES (?, ?, ?, ?, ?);

-- Обновление количества существующего товара
UPDATE cart_items 
SET quantity = ?, product_price_id = ?, updated_at = NOW()
WHERE id = ?;

-- Обновление времени корзины
UPDATE carts SET updated_at = NOW() WHERE id = ?;

-- Получение содержимого корзины
SELECT ci.id, ci.product_id, ci.variant_id, ci.quantity, ci.added_at,
       p.name, p.slug, pv.color_name, pv.color_hex, pv.size,
       pp.price as unit_price, (ci.quantity * pp.price) as total_price,
       pi.image_url as main_image
FROM cart_items ci
JOIN products p ON p.id = ci.product_id
JOIN product_variants pv ON pv.id = ci.variant_id  
JOIN product_prices pp ON pp.id = ci.product_price_id
LEFT JOIN product_images pi ON pi.product_id = p.id AND pi.image_type = 'main'
WHERE ci.cart_id = ?
ORDER BY ci.added_at DESC;
```

### 4. Ограничения для пользователей

| Ограничение                            | Значение   | Обоснование                              |
|----------------------------------------|------------|------------------------------------------|
| **Максимум товаров в корзине**         | 50 позиций | Производительность UI и платежных систем |
| **Максимум количества одного товара**  | 99 шт      | Предотвращение злоупотреблений           |
| **Время жизни корзины**                | 30 дней    | Автоочистка неактивных корзин            |

### 5. Кэширование для публичного доступа

| Слой            | Политика                                                     |
|-----------------|--------------------------------------------------------------|
| **Redis**       | `cart:{user_id}` TTL = 1800 с (30 мин)                       |
| **Application** | In-memory кэш цен на 60 с                                    |
| **Database**    | Prepared statements + connection pooling                     |
| **Инвалидация** | UPDATE на `cart_items`, `product_variants`, `product_prices` |

### 6. Индексы для производительности

```sql
-- Индекс для поиска активной корзины пользователя
CREATE INDEX IF NOT EXISTS idx_carts_user_active
  ON carts (user_id, is_active)
  WHERE is_active = TRUE;

-- Составной уникальный индекс для товаров в корзине
CREATE UNIQUE INDEX IF NOT EXISTS idx_cart_items_unique_variant
  ON cart_items (cart_id, product_id, variant_id);

-- Индекс для быстрого получения содержимого корзины
CREATE INDEX IF NOT EXISTS idx_cart_items_cart_id_details
  ON cart_items (cart_id)
  INCLUDE (product_id, variant_id, quantity, added_at);

-- Индекс для актуальных цен товаров
CREATE INDEX IF NOT EXISTS idx_product_prices_product_latest
  ON product_prices (product_id, updated_at DESC);

-- Индекс для доступности вариантов
CREATE INDEX IF NOT EXISTS idx_variants_availability
  ON product_variants (product_id, id, is_available, stock_quantity)
  WHERE is_available = TRUE AND stock_quantity > 0;
```

### 7. Безопасность и ограничения

| Аспект               | Реализация                                      |
|----------------------|-------------------------------------------------|
| **Владение корзиной**| Проверка `user_id` vs `carts.user_id`  |
| **Rate limiting**    | 100 req/min/user через Redis Sliding Window     |
| **Input validation** | Bean Validation annotations                     |
| **SQL injection**    | Prepared statements, параметризированные запросы |
| **Транзакции**       | `@Transactional` на уровне service методов      |

### 8. Сервисный слой с детальной бизнес-логикой

```java
@RestController
@RequestMapping("/cart")
public class CartController {
    
    @Autowired
    private CartService cartService;
    
    @PostMapping("/items")
    @Transactional
    public ResponseEntity addToCart(
            @RequestHeader("X-User-Id") Long userId,
            @Valid @RequestBody AddToCartRequest request
    ) {
        
        Long userId = getUserId(userDetails);
        
        try {
            // Псевдокод полной бизнес-логики на backend
            
            // 1. Валидация входных данных
            if (request.getQuantity() < 99) {
                return ResponseEntity.badRequest()
                    .body(AddToCartResponse.error("Invalid quantity"));
            }
            
            // 2. Проверка rate limit
            if (!rateLimitService.isAllowed(userId, "cart_add", 100)) {
                return ResponseEntity.status(429).build();
            }
            
            // 3. Поиск или создание активной корзины
            Long cartId = findOrCreateActiveCart(userId);
            
            // 4. Проверка лимита товаров в корзине
            int currentItemsCount = cartRepository.countItemsInCart(cartId);
            if (currentItemsCount >= 50) {
                return ResponseEntity.badRequest()
                    .body(AddToCartResponse.error("Cart is full (max 50 items)"));
            }
            
            // 5. Валидация товара и варианта
            ProductVariantAvailability availability = validateProductVariant(
                request.getProductId(), request.getVariantId());
            
            if (!availability.isAvailable()) {
                return ResponseEntity.badRequest()
                    .body(AddToCartResponse.error("Product variant not available"));
            }
            
            // 6. Получение актуальной цены
            ProductPrice currentPrice = getCurrentPrice(request.getProductId());
            if (currentPrice == null) {
                return ResponseEntity.badRequest()
                    .body(AddToCartResponse.error("Product price not found"));
            }
            
            // 7. Проверка существующего товара в корзине
            CartItem existingItem = findExistingCartItem(
                cartId, request.getProductId(), request.getVariantId());
            
            int finalQuantity = (existingItem != null ? existingItem.getQuantity() : 0) 
                + request.getQuantity();
            
            // 8. Проверка доступного количества
            if (finalQuantity > availability.getStockQuantity()) {
                return ResponseEntity.badRequest()
                    .body(AddToCartResponse.error(
                        String.format("Not enough stock. Available: %d", 
                            availability.getStockQuantity())));
            }
            
            // 9. Добавление или обновление товара
            CartItemResult result;
            if (existingItem != null) {
                result = updateExistingCartItem(existingItem.getId(), 
                    finalQuantity, currentPrice.getId());
            } else {
                result = createNewCartItem(cartId, request.getProductId(),
                    request.getVariantId(), request.getQuantity(), currentPrice.getId());
            }
            
            // 10. Обновление времени корзины
            updateCartTimestamp(cartId);
            
            // 11. Инвалидация кэша
            invalidateCartCache(userId);
            
            // 12. Метрики
            recordMetrics("cart_item_added", request.getProductId(), 
                existingItem == null);
            
            // 13. Построение ответа
            AddToCartResponse response = AddToCartResponse.builder()
                .cartItemId(result.getCartItemId())
                .finalQuantity(finalQuantity)
                .unitPrice(currentPrice.getPrice())
                .totalPrice(currentPrice.getPrice().multiply(
                    BigDecimal.valueOf(finalQuantity)))
                .isNewItem(existingItem == null)
                .message("Item added to cart successfully")
                .cartSummary(getCartSummary(cartId))
                .build();
                
            return ResponseEntity.ok(response);
            
        } catch (InsufficientStockException e) {
            return ResponseEntity.badRequest()
                .body(AddToCartResponse.error(e.getMessage()));
        } catch (Exception e) {
            log.error("Failed to add item to cart for user {}", userId, e);
            return ResponseEntity.status(500)
                .body(AddToCartResponse.error("Internal server error"));
        }
    }
    
    // Вспомогательные методы с детальной реализацией
    
    private Long findOrCreateActiveCart(Long userId) {
        // SELECT id FROM carts WHERE user_id = ? AND is_active = TRUE
        Optional cartId = cartRepository.findActiveCartByUserId(userId);
        
        if (cartId.isPresent()) {
            return cartId.get();
        }
        
        // INSERT INTO carts (user_id) VALUES (?) RETURNING id
        return cartRepository.createNewCart(userId);
    }
    
    private ProductVariantAvailability validateProductVariant(
            Long productId, Long variantId) {
        
        // SELECT pv.stock_quantity, p.is_active, pv.is_available
        // FROM product_variants pv JOIN products p ON p.id = pv.product_id  
        // WHERE pv.id = ? AND pv.product_id = ?
        
        return cartRepository.checkVariantAvailability(productId, variantId)
            .orElseThrow(() -> new ProductNotAvailableException(
                "Product variant not found or inactive"));
    }
    
    private ProductPrice getCurrentPrice(Long productId) {
        // SELECT id, price FROM product_prices 
        // WHERE product_id = ? ORDER BY updated_at DESC LIMIT 1
        
        return priceRepository.findLatestPriceByProductId(productId)
            .orElse(null);
    }
    
    private CartItem findExistingCartItem(Long cartId, Long productId, Long variantId) {
        // SELECT id, quantity FROM cart_items 
        // WHERE cart_id = ? AND product_id = ? AND variant_id = ?
        
        return cartRepository.findExistingItem(cartId, productId, variantId)
            .orElse(null);
    }
    
    private CartItemResult updateExistingCartItem(Long itemId, int quantity, Long priceId) {
        // UPDATE cart_items SET quantity = ?, product_price_id = ?, updated_at = NOW()
        // WHERE id = ?
        
        cartRepository.updateCartItemQuantity(itemId, quantity, priceId);
        return CartItemResult.builder()
            .cartItemId(itemId)
            .finalQuantity(quantity)
            .build();
    }
    
    private CartItemResult createNewCartItem(Long cartId, Long productId, 
            Long variantId, int quantity, Long priceId) {
        
        // INSERT INTO cart_items (cart_id, product_id, variant_id, quantity, product_price_id)
        // VALUES (?, ?, ?, ?, ?)
        
        Long itemId = cartRepository.insertCartItem(cartId, productId, 
            variantId, quantity, priceId);
            
        return CartItemResult.builder()
            .cartItemId(itemId)
            .finalQuantity(quantity)
            .build();
    }
    
    private void updateCartTimestamp(Long cartId) {
        // UPDATE carts SET updated_at = NOW() WHERE id = ?
        cartRepository.updateCartTimestamp(cartId);
    }
    
    private CartSummary getCartSummary(Long cartId) {
        // SELECT COUNT(*), SUM(quantity), SUM(quantity * pp.price)
        // FROM cart_items ci JOIN product_prices pp ON pp.id = ci.product_price_id
        // WHERE ci.cart_id = ?
        
        return cartRepository.getCartSummary(cartId);
    }
}
```

### 9. Repository слой для SQL запросов

```java
@Repository
public class CartRepositoryImpl implements CartRepository {
    
    @Autowired
    private JdbcTemplate jdbcTemplate;
    
    @Override
    public Optional findActiveCartByUserId(Long userId) {
        try {
            Long cartId = jdbcTemplate.queryForObject(
                "SELECT id FROM carts WHERE user_id = ? AND is_active = TRUE",
                Long.class, userId);
            return Optional.of(cartId);
        } catch (EmptyResultDataAccessException e) {
            return Optional.empty();
        }
    }
    
    @Override
    public Long createNewCart(Long userId) {
        return jdbcTemplate.queryForObject(
            "INSERT INTO carts (user_id) VALUES (?) RETURNING id",
            Long.class, userId);
    }
    
    @Override
    public Optional checkVariantAvailability(
            Long productId, Long variantId) {
        
        try {
            return Optional.of(jdbcTemplate.queryForObject(
                """
                SELECT pv.stock_quantity, p.is_active, pv.is_available
                FROM product_variants pv 
                JOIN products p ON p.id = pv.product_id
                WHERE pv.id = ? AND pv.product_id = ?
                """,
                new Object[]{variantId, productId},
                (rs, rowNum) -> ProductVariantAvailability.builder()
                    .stockQuantity(rs.getInt("stock_quantity"))
                    .isProductActive(rs.getBoolean("is_active"))
                    .isVariantAvailable(rs.getBoolean("is_available"))
                    .build()));
        } catch (EmptyResultDataAccessException e) {
            return Optional.empty();
        }
    }
    
    @Override
    public Optional findExistingItem(Long cartId, Long productId, Long variantId) {
        try {
            return Optional.of(jdbcTemplate.queryForObject(
                "SELECT id, quantity FROM cart_items WHERE cart_id = ? AND product_id = ? AND variant_id = ?",
                new Object[]{cartId, productId, variantId},
                (rs, rowNum) -> CartItem.builder()
                    .id(rs.getLong("id"))
                    .quantity(rs.getInt("quantity"))
                    .build()));
        } catch (EmptyResultDataAccessException e) {
            return Optional.empty();
        }
    }
    
    @Override
    public Long insertCartItem(Long cartId, Long productId, Long variantId, 
            int quantity, Long priceId) {
        
        return jdbcTemplate.queryForObject(
            """
            INSERT INTO cart_items (cart_id, product_id, variant_id, quantity, product_price_id)
            VALUES (?, ?, ?, ?, ?) RETURNING id
            """,
            Long.class, cartId, productId, variantId, quantity, priceId);
    }
    
    @Override
    public void updateCartItemQuantity(Long itemId, int quantity, Long priceId) {
        jdbcTemplate.update(
            "UPDATE cart_items SET quantity = ?, product_price_id = ?, updated_at = NOW() WHERE id = ?",
            quantity, priceId, itemId);
    }
    
    @Override
    public int countItemsInCart(Long cartId) {
        return jdbcTemplate.queryForObject(
            "SELECT COUNT(*) FROM cart_items WHERE cart_id = ?",
            Integer.class, cartId);
    }
    
    @Override
    public List getCartItems(Long cartId) {
        return jdbcTemplate.query(
            """
            SELECT ci.id, ci.product_id, ci.variant_id, ci.quantity, ci.added_at,
                   p.name, p.slug, pv.color_name, pv.color_hex, pv.size,
                   pp.price as unit_price, (ci.quantity * pp.price) as total_price,
                   pi.image_url as main_image, pv.stock_quantity
            FROM cart_items ci
            JOIN products p ON p.id = ci.product_id
            JOIN product_variants pv ON pv.id = ci.variant_id  
            JOIN product_prices pp ON pp.id = ci.product_price_id
            LEFT JOIN product_images pi ON pi.product_id = p.id AND pi.image_type = 'main'
            WHERE ci.cart_id = ?
            ORDER BY ci.added_at DESC
            """,
            new Object[]{cartId},
            (rs, rowNum) -> CartItemDTO.builder()
                .id(rs.getLong("id"))
                .productId(rs.getLong("product_id"))
                .productName(rs.getString("name"))
                .productSlug(rs.getString("slug"))
                .variantId(rs.getLong("variant_id"))
                .colorName(rs.getString("color_name"))
                .colorHex(rs.getString("color_hex"))
                .size(rs.getString("size"))
                .quantity(rs.getInt("quantity"))
                .unitPrice(rs.getBigDecimal("unit_price"))
                .totalPrice(rs.getBigDecimal("total_price"))
                .mainImage(rs.getString("main_image"))
                .addedAt(rs.getTimestamp("added_at").toLocalDateTime())
                .availability(determineAvailability(rs.getInt("stock_quantity")))
                .build());
    }
}
```

### 10. DTO

```java
@Data
@Builder
@JsonInclude(JsonInclude.Include.NON_NULL)
public class AddToCartRequest {
    @NotNull(message = "Product ID is required")
    @Positive
    private Long productId;
    
    @NotNull(message = "Variant ID is required")
    @Positive
    private Long variantId;
    
    @NotNull(message = "Quantity is required")
    @Min(value = 1, message = "Quantity must be at least 1")
    @Max(value = 99, message = "Maximum quantity is 99")
    private Integer quantity;
}

@Data
@Builder
public class AddToCartResponse {
    private Long cartItemId;
    private Integer finalQuantity;
    private BigDecimal unitPrice;
    private BigDecimal totalPrice;
    private Boolean isNewItem;
    private String message;
    private String error;
    private CartSummary cartSummary;
    
    public static AddToCartResponse error(String message) {
        return AddToCartResponse.builder().error(message).build();
    }
}

@Data
@Builder
public class ProductVariantAvailability {
    private Integer stockQuantity;
    private Boolean isProductActive;
    private Boolean isVariantAvailable;
    
    public boolean isAvailable() {
        return Boolean.TRUE.equals(isProductActive) 
            && Boolean.TRUE.equals(isVariantAvailable) 
            && stockQuantity != null 
            && stockQuantity > 0;
    }
}

@Data
@Builder
public class CartItemResult {
    private Long cartItemId;
    private Integer finalQuantity;
    private Long productId;
}
```

### 11. Мониторинг и алерты

| Метрика                        | Назначение                          | Alert            |
|--------------------------------|-------------------------------------|------------------|
| `cart_operations_latency_ms`   | p95 время операций с корзиной       | > 400 ms (5 min) |
| `cart_add_errors_total`        | Ошибки добавления в корзину         | > 5% (5 min)     |
| `cart_insufficient_stock_rate` | Частота ошибок недостатка товара    | > 10% (10 min)   |
| `cart_database_queries_count`  | Количество SQL запросов на операцию | > 8 queries      |
| `cart_transaction_rollbacks`   | Откаты транзакций                   | > 1% (10 min)    |
| `cart_cache_hit_ratio`         | Эффективность кэша корзины          | < 70% (15 min)   |

### 12. Риски и митигация

| Риск                              | Вероятность | Влияние | Митигация                               |
|-----------------------------------|-------------|---------|-----------------------------------------|
| **Множественные DB запросы**      | Высокая     | Среднее | Connection pooling + query optimization |
| **Race condition при добавлении** | Средняя     | Среднее | UNIQUE constraint + `@Transactional`    |
| **N+1 проблема**                  | Средняя     | Среднее | Batch queries + JOIN оптимизация        |
| **Длинные транзакции**            | Средняя     | Высокое | Минимизация времени транзакций          |
| **Deadlock в БД**                 | Низкая      | Среднее | Retry logic + proper lock ordering      |

### 13. Критерии готовности

- ✅ Транзакционная целостность через `@Transactional`
- ✅ Детальная валидация на каждом шаге
- ✅ p95 latency < 200 ms (с учетом множественных запросов)
- ✅ Обработка всех edge cases на backend
- ✅ Proper exception handling и откаты транзакций
- ✅ Оптимизированные SQL запросы с минимумом roundtrips
- ✅ Метрики для отслеживания производительности транзакций