**ML-006** - Как пользователь, я хочу видеть итоговую стоимость товаров

## Постановка задачи для бэкенд-разработчика
**Тема:** «Расчет итоговой стоимости товаров в корзине без скидок и промокодов»

### 1. Цель
Предоставить пользователям простой и быстрый расчет итоговой стоимости всех товаров в корзине с актуальными ценами, 
количеством товаров и общей суммой заказа в режиме реального времени при изменении содержимого корзины.

### 2. Требования к API

| Параметр            | Описание                                         |
|---------------------|--------------------------------------------------|
| `GET /cart/total`   | Получение итоговой стоимости корзины             |
| `GET /cart/summary` | Детальный расчет с разбивкой по товарам          |
| Query-параметры     | `includeTax=true/false` (для расчета налогов)    |
| Headers             | `Authorization: Bearer {token}` обязательный     |
| Время ответа        | p95 ≤ 150 ms                                     |
| Rate limit          | 300 req/min/user для расчетов стоимости          |
| Формат ответа       | JSON с детализацией по товарам и итоговой суммой |

### 3. Доступность

Функциональность доступна **всем пользователям**.

### 4. Ограничения для пользователей

| Ограничение                       | Значение              | Обоснование                 |
|-----------------------------------|-----------------------|-----------------------------|
| **Максимум товаров для расчета**  | 100 позиций           | Производительность расчетов |
| **Минимальная стоимость заказа**  | 1 ₽                   | Технические ограничения     |
| **Максимальная стоимость заказа** | 1,000,000 ₽           | Предотвращение переполнения |
| **Точность расчетов**             | 2 знака после запятой | Стандарт валютных операций  |
| **Время жизни расчета**           | 10 минут              | Актуальность цен            |

### 5. Кэширование для публичного доступа

| Слой            | Политика                                                |
|-----------------|---------------------------------------------------------|
| **Redis**       | `cart_total:{user_id}:{cart_hash}` TTL = 600 с (10 мин) |
| **Application** | In-memory кэш актуальных цен на 120 с                   |
| **Database**    | Connection pooling для запросов цен                     |
| **Инвалидация** | UPDATE на `cart_items`, `product_prices`                |

### 6. Индексы для производительности

```sql
-- Индекс для быстрого получения товаров корзины с ценами
CREATE INDEX IF NOT EXISTS idx_cart_items_total_calculation
  ON cart_items (cart_id)
  INCLUDE (product_id, variant_id, quantity);

-- Индекс для актуальных цен товаров
CREATE INDEX IF NOT EXISTS idx_product_prices_latest
  ON product_prices (product_id, updated_at DESC);

-- Индекс для активных товаров в расчетах
CREATE INDEX IF NOT EXISTS idx_products_active_price_calc
  ON products (id, is_active)
  WHERE is_active = TRUE;

-- Индекс для вариантов товаров в расчетах
CREATE INDEX IF NOT EXISTS idx_variants_cart_calculation
  ON product_variants (id, product_id, is_available)
  WHERE is_available = TRUE;
```

### 7. Безопасность и ограничения

| Аспект                 | Реализация                                          |
|------------------------|-----------------------------------------------------|
| **Владение данными**   | Проверка принадлежности корзины пользователю        |
| **Rate limiting**      | 300 req/min/user для предотвращения злоупотреблений |
| **Валидация цен**      | Проверка на отрицательные значения и переполнение   |
| **Целостность данных** | Проверка существования товаров и вариантов          |

### 8. Сервисный слой (Java/Spring пример)

```java
@RestController
@RequestMapping("/cart")
public class CartTotalController {
    
    @Autowired
    private CartTotalService cartTotalService;
    
    @Autowired
    private RedisTemplate redisTemplate;
    
    @GetMapping("/total")
    public ResponseEntity getCartTotal(
            @RequestParam(defaultValue = "false") Boolean includeTax,
            @RequestHeader("X-User-Id") Long userId
    ) {
        
        Long userId = getUserId(userDetails);
        
        try {
            // Псевдокод расчета итоговой стоимости
            
            // 1. Получение корзины пользователя
            Long cartId = findActiveCartId(userId);
            if (cartId == null) {
                return ResponseEntity.ok(CartTotalResponse.empty());
            }
            
            // 2. Построение хэша для кэширования
            String cartHash = calculateCartHash(cartId);
            String cacheKey = String.format("cart_total:%d:%s:%s", 
                userId, cartHash, includeTax);
            
            // 3. Проверка кэша
            CartTotalResponse cached = (CartTotalResponse) redisTemplate.opsForValue().get(cacheKey);
            if (cached != null) {
                meterRegistry.counter("cart_total_cache_hit").increment();
                return ResponseEntity.ok(cached);
            }
            
            // 4. Получение товаров корзины
            List cartItems = getCartItemsWithPrices(cartId);
            if (cartItems.isEmpty()) {
                return ResponseEntity.ok(CartTotalResponse.empty());
            }
            
            // 5. Расчет стоимости каждого товара
            List itemTotals = new ArrayList<>();
            BigDecimal subtotal = BigDecimal.ZERO;
            
            for (CartItemWithPrice item : cartItems) {
                // 5.1. Валидация товара
                if (!isItemValid(item)) {
                    continue; // Пропускаем недоступные товары
                }
                
                // 5.2. Расчет стоимости позиции
                BigDecimal itemPrice = item.getCurrentPrice();
                BigDecimal itemTotal = itemPrice.multiply(BigDecimal.valueOf(item.getQuantity()));
                
                itemTotals.add(CartItemTotal.builder()
                    .cartItemId(item.getCartItemId())
                    .productId(item.getProductId())
                    .productName(item.getProductName())
                    .variantId(item.getVariantId())
                    .colorName(item.getColorName())
                    .size(item.getSize())
                    .quantity(item.getQuantity())
                    .unitPrice(itemPrice)
                    .totalPrice(itemTotal)
                    .build());
                
                subtotal = subtotal.add(itemTotal);
            }
            
            // 6. Расчет налогов (если требуется)
            BigDecimal taxAmount = BigDecimal.ZERO;
            if (includeTax) {
                taxAmount = calculateTax(subtotal); // Например, 20% НДС
            }
            
            // 7. Итоговая сумма
            BigDecimal finalTotal = subtotal.add(taxAmount);
            
            // 8. Построение ответа
            CartTotalResponse response = CartTotalResponse.builder()
                .cartId(cartId)
                .items(itemTotals)
                .itemsCount(itemTotals.size())
                .totalQuantity(calculateTotalQuantity(itemTotals))
                .subtotal(subtotal)
                .taxAmount(taxAmount)
                .finalTotal(finalTotal)
                .currency("RUB")
                .calculatedAt(LocalDateTime.now())
                .build();
            
            // 9. Кэширование результата
            redisTemplate.opsForValue().set(cacheKey, response, Duration.ofMinutes(10));
            
            // 10. Метрики
            recordTotalCalculationMetrics(itemTotals.size(), subtotal);
            
            return ResponseEntity.ok()
                .cacheControl(CacheControl.maxAge(Duration.ofMinutes(5)))
                .body(response);
                
        } catch (Exception e) {
            log.error("Failed to calculate cart total for user {}", userId, e);
            meterRegistry.counter("cart_total_errors").increment();
            return ResponseEntity.status(500).build();
        }
    }
    
    @GetMapping("/summary")
    public ResponseEntity getDetailedSummary(
            @AuthenticationPrincipal UserDetails userDetails) {
        
        Long userId = getUserId(userDetails);
        
        // Псевдокод детального расчета
        try {
            // 1. Получение полной информации о корзине
            CartWithDetails cartDetails = getCartWithFullDetails(userId);
            if (cartDetails == null || cartDetails.getItems().isEmpty()) {
                return ResponseEntity.ok(CartSummaryResponse.empty());
            }
            
            // 2. Группировка товаров по категориям
            Map> itemsByCategory = groupItemsByCategory(
                cartDetails.getItems());
            
            // 3. Расчет статистики
            CartStatistics statistics = calculateCartStatistics(cartDetails.getItems());
            
            // 4. Построение детального ответа
            CartSummaryResponse response = CartSummaryResponse.builder()
                .cartId(cartDetails.getCartId())
                .itemsByCategory(itemsByCategory)
                .statistics(statistics)
                .warnings(validateCartForWarnings(cartDetails))
                .lastUpdated(cartDetails.getLastUpdated())
                .build();
                
            return ResponseEntity.ok(response);
            
        } catch (Exception e) {
            log.error("Failed to get cart summary for user {}", userId, e);
            return ResponseEntity.status(500).build();
        }
    }
    
    // Вспомогательные методы
    
    private Long findActiveCartId(Long userId) {
        // SELECT id FROM carts WHERE user_id = ? AND is_active = TRUE
        return cartRepository.findActiveCartByUserId(userId).orElse(null);
    }
    
    private List getCartItemsWithPrices(Long cartId) {
        // SQL запрос для получения товаров с актуальными ценами
        String sql = """
            SELECT ci.id as cart_item_id, ci.product_id, ci.variant_id, ci.quantity,
                   p.name as product_name, p.is_active,
                   pv.color_name, pv.size, pv.is_available,
                   COALESCE(pp.price, p.base_price) as current_price
            FROM cart_items ci
            JOIN products p ON p.id = ci.product_id
            JOIN product_variants pv ON pv.id = ci.variant_id
            LEFT JOIN LATERAL (
                SELECT price FROM product_prices 
                WHERE product_id = p.id 
                ORDER BY updated_at DESC 
                LIMIT 1
            ) pp ON TRUE
            WHERE ci.cart_id = ?
            ORDER BY ci.added_at
            """;
            
        return jdbcTemplate.query(sql, new Object[]{cartId}, 
            (rs, rowNum) -> CartItemWithPrice.builder()
                .cartItemId(rs.getLong("cart_item_id"))
                .productId(rs.getLong("product_id"))
                .productName(rs.getString("product_name"))
                .variantId(rs.getLong("variant_id"))
                .colorName(rs.getString("color_name"))
                .size(rs.getString("size"))
                .quantity(rs.getInt("quantity"))
                .currentPrice(rs.getBigDecimal("current_price"))
                .isProductActive(rs.getBoolean("is_active"))
                .isVariantAvailable(rs.getBoolean("is_available"))
                .build());
    }
    
    private boolean isItemValid(CartItemWithPrice item) {
        return item.isProductActive() && 
               item.isVariantAvailable() && 
               item.getCurrentPrice() != null &&
               item.getCurrentPrice().compareTo(BigDecimal.ZERO) > 0;
    }
    
    private BigDecimal calculateTax(BigDecimal subtotal) {
        // Простой расчет НДС 20%
        return subtotal.multiply(new BigDecimal("0.20"))
                      .setScale(2, RoundingMode.HALF_UP);
    }
    
    private String calculateCartHash(Long cartId) {
        // Создание хэша на основе содержимого корзины для кэширования
        String cartData = jdbcTemplate.queryForObject(
            """
            SELECT string_agg(
                ci.product_id::text || '_' || ci.variant_id::text || '_' || ci.quantity::text, 
                ','
                ORDER BY ci.id
            )
            FROM cart_items ci 
            WHERE ci.cart_id = ?
            """, 
            String.class, cartId);
            
        return DigestUtils.md5Hex(cartData != null ? cartData : "empty");
    }
    
    private void recordTotalCalculationMetrics(int itemsCount, BigDecimal total) {
        meterRegistry.counter("cart_total_calculations").increment();
        meterRegistry.gauge("cart_average_items_count", itemsCount);
        meterRegistry.gauge("cart_average_total_amount", total.doubleValue());
    }
}
```

### 9. DTO

```java
@Data
@Builder
@JsonInclude(JsonInclude.Include.NON_NULL)
public class CartTotalResponse {
    private Long cartId;
    private List items;
    private Integer itemsCount;
    private Integer totalQuantity;
    private BigDecimal subtotal;
    private BigDecimal taxAmount;
    private BigDecimal finalTotal;
    private String currency;
    private LocalDateTime calculatedAt;
    private List warnings;
    
    public static CartTotalResponse empty() {
        return CartTotalResponse.builder()
            .items(Collections.emptyList())
            .itemsCount(0)
            .totalQuantity(0)
            .subtotal(BigDecimal.ZERO)
            .taxAmount(BigDecimal.ZERO)
            .finalTotal(BigDecimal.ZERO)
            .currency("RUB")
            .calculatedAt(LocalDateTime.now())
            .build();
    }
}

@Data
@Builder
public class CartItemTotal {
    private Long cartItemId;
    private Long productId;
    private String productName;
    private String productSlug;
    private Long variantId;
    private String colorName;
    private String colorHex;
    private String size;
    private Integer quantity;
    private BigDecimal unitPrice;
    private BigDecimal totalPrice;
    private String productImage;
}

@Data
@Builder
public class CartSummaryResponse {
    private Long cartId;
    private Map> itemsByCategory;
    private CartStatistics statistics;
    private List warnings;
    private LocalDateTime lastUpdated;
    
    public static CartSummaryResponse empty() {
        return CartSummaryResponse.builder()
            .itemsByCategory(Collections.emptyMap())
            .statistics(CartStatistics.empty())
            .warnings(Collections.emptyList())
            .lastUpdated(LocalDateTime.now())
            .build();
    }
}

@Data
@Builder
public class CartStatistics {
    private Integer totalItems;
    private Integer totalQuantity;
    private BigDecimal totalAmount;
    private BigDecimal averageItemPrice;
    private BigDecimal minItemPrice;
    private BigDecimal maxItemPrice;
    private Integer uniqueProducts;
    
    public static CartStatistics empty() {
        return CartStatistics.builder()
            .totalItems(0)
            .totalQuantity(0)
            .totalAmount(BigDecimal.ZERO)
            .averageItemPrice(BigDecimal.ZERO)
            .minItemPrice(BigDecimal.ZERO)
            .maxItemPrice(BigDecimal.ZERO)
            .uniqueProducts(0)
            .build();
    }
}

@Data
@Builder
public class CartItemWithPrice {
    private Long cartItemId;
    private Long productId;
    private String productName;
    private Long variantId;
    private String colorName;
    private String size;
    private Integer quantity;
    private BigDecimal currentPrice;
    private Boolean isProductActive;
    private Boolean isVariantAvailable;
}
```

### 10. Мониторинг и алерты

| Метрика                             | Назначение                 | Alert            |
|-------------------------------------|----------------------------|------------------|
| `cart_total_calculations_per_sec`   | Частота расчетов стоимости | > 100 req/sec    |
| `cart_total_calculation_latency_ms` | p95 время расчета          | > 300 ms (5 min) |
| `cart_total_errors_rate`            | Доля ошибок в расчетах     | > 2% (5 min)     |
| `cart_total_cache_hit_ratio`        | Эффективность кэша         | 30% (10 min)     |

### 11. Риски и митигация

| Риск                                | Вероятность | Влияние                                          | Митигация                         |
|-------------------------------------|-------------|--------------------------------------------------|-----------------------------------|
| **Устаревшие цены в расчетах**      | Высокая     | Среднее   Кэш TTL 10 мин + real-time инвалидация |
| **Товар стал недоступен**           | Средняя     | Низкое                                           | Валидация доступности при расчете |
| **Переполнение при больших суммах** | Низкая      | Среднее                                          | Лимит 1,000,000 ₽ + BigDecimal    |
| **Медленные запросы к БД**          | Средняя     | Высокое                                          | Индексы + connection pooling      |
| **Кэш рассинхронизация**            | Средняя     | Среднее                                          | Hash-based cache keys + TTL       |
| **Высокая нагрузка на расчеты**     | Средняя     | Среднее                                          | Rate limiting + Redis cache       |

### 12. Критерии готовности

- ✅ Пользователь получает точную итоговую стоимость всех товаров в корзине
- ✅ Расчет использует актуальные цены товаров
- ✅ Корректная обработка недоступных товаров (исключение из расчета)
- ✅ p95 latency  70% для повторных запросов
- ✅ Точность расчетов до 2 знаков после запятой
- ✅ Валидация всех входных данных и цен
- ✅ Детальная разбивка по товарам и категориям
- ✅ Метрики для отслеживания производительности
- ✅ Обработка edge cases (пустая корзина, недоступные товары)
- ✅ Эффективное кэширование с автоматической инвалидацией
- ✅ Масштабируемость до 300 RPS на пользователя