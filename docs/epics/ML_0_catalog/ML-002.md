**ML-002** - Как пользователь, я хочу фильтровать товары по размеру, цвету, цене и типу товара, чтобы быстро находить подходящее

## Постановка задачи для бэкенд-разработчика (обновленная)
**Тема:** «Фильтрация товаров по размеру, цвету, цене и типу через поля в таблице products»

### 1. Цель
Реализовать фильтрацию товаров с захардкоженными в UI фильтрами, используя только прямые поля в таблицах `products`, `product_variants`, `categories` без сложной системы динамических фильтров.

### 2. Обновленные требования к API

```http
GET api/v1/catalog
  ?categories=women,men,accessories,art
  &colors=red,blue,green,black
  &sizes=XS,S,M,L,XL,XXL  
  &minPrice=1000
  &maxPrice=50000
  &cursor=base64cursor
  &limit=24
```

### 3. Упрощенная логика фильтрации

```sql
WITH variant_products AS (
  SELECT DISTINCT pv.product_id,
         pv.color_name,
         pv.size,
         (p.base_price + pv.additional_price) AS final_price
    FROM product_variants pv
    JOIN products p ON p.id = pv.product_id
   WHERE pv.is_available = TRUE
     AND pv.stock_quantity > 0
     AND (:sizes IS NULL OR pv.size = ANY(:sizes))
     AND (:colors IS NULL OR LOWER(pv.color_name) = ANY(:colors))
)
SELECT p.*, 
       vp.final_price,
       c.slug as category_slug,
       pi.image_url
  FROM products p
  JOIN variant_products vp ON vp.product_id = p.id
  JOIN categories c ON c.id = p.category_id  
  JOIN product_images pi ON pi.product_id = p.id AND pi.image_type = 'main'
 WHERE p.is_active = TRUE
   AND c.is_active = TRUE
   AND (:categories IS NULL OR c.slug = ANY(:categories))
   AND (:minPrice IS NULL OR vp.final_price >= :minPrice)
   AND (:maxPrice IS NULL OR vp.final_price  (:sIdx, :cAt, :pId)
 ORDER BY sort_index ASC, created_at DESC, p.id DESC
 LIMIT :limit;
```

### 4. Схема захардкоженных фильтров в UI

| Фильтр        | Источник данных                 | Захардкоженные значения                                       |
|---------------|---------------------------------|---------------------------------------------------------------|
| **Категории** | `categories.slug`               | `['women', 'men', 'accessories', 'art']`                      |
| **Цвета**     | `product_variants.color_name`   | `['red', 'blue', 'green', 'black', 'white', 'gray', 'brown']` |
| **Размеры**   | `product_variants.size`         | `['XS', 'S', 'M', 'L', 'XL', 'XXL']`                          |
| **Цена**      | `base_price + additional_price` | Слайдер от 0 до 500,000 ₽                                     |

### 5. Необходимые индексы

```sql
-- Основной индекс для курсора
CREATE INDEX IF NOT EXISTS idx_products_sort_created_id
  ON products (sort_index ASC, created_at DESC, id DESC);

-- Индексы для фильтрации через варианты
CREATE INDEX IF NOT EXISTS idx_variants_product_available
  ON product_variants (product_id, is_available, stock_quantity);

CREATE INDEX IF NOT EXISTS idx_variants_size_color
  ON product_variants (size, color_name, product_id);

-- Индекс для категорий
CREATE INDEX IF NOT EXISTS idx_categories_slug_active
  ON categories (slug, is_active);

-- Индекс для главных изображений
CREATE INDEX IF NOT EXISTS idx_images_product_type
  ON product_images (product_id, image_type);
```

### 6. Валидация параметров

```pseudocode
validateFilters(request):
  categories = intersect(request.categories, ALLOWED_CATEGORIES)
  colors = intersect(request.colors, ALLOWED_COLORS)  
  sizes = intersect(request.sizes, ALLOWED_SIZES)
  
  if minPrice > maxPrice:
    throw BadRequest("minPrice не может быть больше maxPrice")
    
  if minPrice  500000:
    throw BadRequest("Некорректный ценовой диапазон")
```

### 7. Кэширование

| Ключ Redis                                                                      | TTL   | Инвалидация                                            |
|---------------------------------------------------------------------------------|-------|--------------------------------------------------------|
| `cat_simple:{hash(categories,colors,sizes,minPrice,maxPrice)}:{cursor}:{limit}` | 60 с  | UPDATE на `products`, `product_variants`, `categories` |

### 8. Сервисный слой

```pseudocode
CatalogService.fetchWithSimpleFilters(filters, cursor, limit):
  1. validateFilters(filters)
  2. decodeCursor(cursor) → (sortIndex, createdAt, id)  
  3. cacheKey = buildCacheKey(filters, cursor, limit)
  4. cached = redis.get(cacheKey)
  5. if cached: return cached
  6. result = repository.findWithFilters(filters, cursorTriple, limit)
  7. redis.setex(cacheKey, 60, result)
  8. return result
```

### 9. Метрики

| Метрика                                        | Назначение                             |
|------------------------------------------------|----------------------------------------|
| `catalog_simple_filter_hit_total{filter_type}` | Использование каждого типа фильтра.    |
| `catalog_simple_filter_latency_ms`             | p95 время ответа с фильтрами.          |
| `catalog_variant_join_rows`                    | Среднее количество вариантов на товар. |

### 10. Тестирование

| Тип         | Кейс                                                                                |
|-------------|-------------------------------------------------------------------------------------|
| Unit        | Валидация фильтров; генерация SQL с разными комбинациями `NULL`.                    |
| Integration | Фильтр по размеру возвращает только товары с доступными вариантами нужного размера. |
| Performance | ≤ 200 мс при 4 одновременных фильтрах и 10,000 товарах.                             |

### 11. Риски и меры

| Риск                                          | Митигирование                                                |
|-----------------------------------------------|--------------------------------------------------------------|
| **Товар без вариантов не попадает в выдачу**  | Создать дефолтный вариант при добавлении товара.             |
| **Медленный `JOIN` с `product_variants`**     | Индекс `idx_variants_product_available` + `EXPLAIN ANALYZE`. |
| **Неточная цена при сложном ценообразовании** | Денормализация итоговой цены в отдельное поле.               |

### 12. План внедрения

1. **Создать индексы** `CONCURRENTLY` на продакшене.
2. **Реализовать упрощенную логику** без таблиц фильтров.
3. **Обновить кэш-ключи** под новую структуру параметров.
4. **Feature flag**: переключение 10% → 100% трафика.
5. **Мониторинг**: убедиться в p95 < 200 мс.