**ML-003** - Как покупатель, я хочу видеть детальную карточку товара с фото, видео и описанием для принятия решения

## Постановка задачи для бэкенд-разработчика
**Тема:** «Детальная карточка товара с фото, видео и описанием для принятия решения о покупке»

### 1. Цель
Предоставить покупателю исчерпывающую информацию о товаре на отдельной странице: высококачественные изображения, видео-контент, подробное описание, варианты, цены, отзывы и рекомендации стилистов для принятия обоснованного решения о покупке.

### 2. Требования к API

| Параметр                      | Описание                                                         |
|-------------------------------|------------------------------------------------------------------|
| `GET /products/{slug}`        | SSR-версия для SEO и прямых ссылок                               |
| `GET /api/v1/products/{id}`   | JSON API для SPA                                                 |
| Параметры                     | `includeReviews=true/false`, `includeRecommendations=true/false` |
| Время ответа                  | p95 ≤ 200 ms                                                     |
| Коды ответа                   | `200` — OK, `404` — товар не найден или неактивен                |

### 3. Логика выборки данных

```sql
WITH 
  current_price AS (
    SELECT DISTINCT ON (product_id) 
           product_id, 
           price,
           updated_at
      FROM product_prices
     WHERE product_id = :productId
     ORDER BY product_id, updated_at DESC
  ),
  product_media AS (
    SELECT product_id,
           image_url,
           alt_text,
           sort_order,
           image_type,
           video_url,
           is_video
      FROM product_images
     WHERE product_id = :productId
     ORDER BY sort_order ASC
  ),
  available_variants AS (
    SELECT product_id,
           color_name,
           color_hex,
           size,
           stock_quantity,
           additional_price,
           (base_price + additional_price) as variant_price
      FROM product_variants pv
      JOIN products p ON p.id = pv.product_id
     WHERE pv.product_id = :productId
       AND pv.is_available = TRUE
       AND pv.stock_quantity > 0
  ),
  reviews_summary AS (
    SELECT product_id,
           COUNT(*) as total_reviews,
           AVG(rating)::NUMERIC(3,2) as avg_rating,
           COUNT(*) FILTER (WHERE rating = 5) as five_star,
           COUNT(*) FILTER (WHERE rating = 4) as four_star,
           COUNT(*) FILTER (WHERE rating = 3) as three_star,
           COUNT(*) FILTER (WHERE rating = 2) as two_star,
           COUNT(*) FILTER (WHERE rating = 1) as one_star
      FROM product_reviews
     WHERE product_id = :productId
       AND is_approved = TRUE
  ),
  styling_recs AS (
    SELECT sr.id,
           sr.title,
           sr.description,
           s.name as stylist_name,
           s.avatar_url as stylist_avatar
      FROM styling_recommendation_products srp
      JOIN styling_recommendations sr ON sr.id = srp.recommendation_id
      JOIN stylists s ON s.id = sr.stylist_id
     WHERE srp.product_id = :productId
       AND s.is_active = TRUE
     LIMIT 3
  )
SELECT p.id,
       p.name,
       p.slug,
       p.description,
       p.base_price,
       p.material,
       p.care_instructions,
       p.created_at,
       COALESCE(cp.price, p.base_price) as current_price,
       c.id as category_id,
       c.name as category_name,
       c.slug as category_slug,
       json_agg(DISTINCT pm.*) as media,
       json_agg(DISTINCT av.*) as variants,
       row_to_json(rs.*) as reviews_summary,
       json_agg(DISTINCT sr.*) as styling_recommendations
  FROM products p
  JOIN categories c ON c.id = p.category_id
  LEFT JOIN current_price cp ON cp.product_id = p.id
  LEFT JOIN product_media pm ON pm.product_id = p.id
  LEFT JOIN available_variants av ON av.product_id = p.id
  LEFT JOIN reviews_summary rs ON rs.product_id = p.id
  LEFT JOIN styling_recs sr ON TRUE
 WHERE p.id = :productId
   AND p.is_active = TRUE
   AND c.is_active = TRUE
 GROUP BY p.id, c.id, cp.price, rs.*;
```

### 4. Индексы для производительности

```sql
-- Основные индексы
CREATE INDEX IF NOT EXISTS idx_products_slug_active
  ON products (slug, is_active)
  WHERE is_active = TRUE;

-- Индекс для актуальных цен
CREATE INDEX IF NOT EXISTS idx_product_prices_product_updated
  ON product_prices (product_id, updated_at DESC);

-- Индекс для медиа с сортировкой
CREATE INDEX IF NOT EXISTS idx_product_images_product_sort
  ON product_images (product_id, sort_order, image_type);

-- Индекс для доступных вариантов
CREATE INDEX IF NOT EXISTS idx_product_variants_available
  ON product_variants (product_id, is_available, stock_quantity)
  WHERE is_available = TRUE AND stock_quantity > 0;

-- Индекс для одобренных отзывов
CREATE INDEX IF NOT EXISTS idx_product_reviews_approved
  ON product_reviews (product_id, is_approved, rating)
  WHERE is_approved = TRUE;

-- Индекс для рекомендаций стилистов
CREATE INDEX IF NOT EXISTS idx_styling_recs_product
  ON styling_recommendation_products (product_id);
```

### 5. Кэширование

| Слой            | Политика                                                                     |
|-----------------|------------------------------------------------------------------------------|
| **Redis**       | `product_detail:{id}` TTL = 300 с (5 мин)                                    |
| **CDN**         | `Cache-Control: public,max-age=600,s-maxage=1800`                            |
| **Edge**        | CloudFlare для статических изображений и видео                               |
| **Инвалидация** | UPDATE на `products`, `product_prices`, `product_images`, `product_variants` |

### 6. Сервисный слой (Spring Boot пример)

```java
@RestController
@RequestMapping("/api/c1/products")
public class ProductDetailController {
    
    @GetMapping("/{id}")
    public ResponseEntity getProductDetail(
            @PathVariable Long id,
            @RequestParam(defaultValue = "true") Boolean includeReviews,
            @RequestParam(defaultValue = "true") Boolean includeRecommendations) {
        
        // Валидация ID
        if (id == null || id  product = productDetailRepository
            .findDetailById(id, includeReviews, includeRecommendations);
        
        if (product.isEmpty()) {
            meterRegistry.counter("product_detail_not_found").increment();
            return ResponseEntity.notFound().build();
        }
        
        ProductDetailDTO result = product.get();
        
        // Дополнительная обработка медиа URLs
        result.setMedia(optimizeMediaUrls(result.getMedia()));
        
        // Сохранение в кэш
        redisTemplate.opsForValue().set(cacheKey, result, 
            Duration.ofSeconds(300));
        
        // Метрики
        meterRegistry.counter("product_detail_served").increment();
        meterRegistry.timer("product_detail_latency")
            .recordCallable(() -> result);
        
        return ResponseEntity.ok()
            .cacheControl(CacheControl.maxAge(Duration.ofSeconds(600)))
            .body(result);
    }
    
    private List optimizeMediaUrls(List media) {
        return media.stream().map(m -> {
            if (m.getType().equals("image")) {
                // Добавляем WebP версии и responsive sizes
                m.setWebpUrl(cdnService.getWebPUrl(m.getUrl()));
                m.setSrcSet(cdnService.getResponsiveSrcSet(m.getUrl()));
            } else if (m.getType().equals("video")) {
                // Добавляем thumbnail и multiple bitrates
                m.setThumbnail(cdnService.getVideoThumbnail(m.getUrl()));
                m.setHlsUrl(cdnService.getHlsUrl(m.getUrl()));
            }
            return m;
        }).collect(Collectors.toList());
    }
}
```

### 7. DTO для детальной карточки

```java
@Data
@Builder
@JsonInclude(JsonInclude.Include.NON_NULL)
public class ProductDetailDTO {
    private Long id;
    private String name;
    private String slug;
    private String description;
    private BigDecimal basePrice;
    private BigDecimal currentPrice;
    private String material;
    private String careInstructions;
    private LocalDateTime createdAt;
    
    // Категория
    private Long categoryId;
    private String categoryName;
    private String categorySlug;
    
    // Медиа контент
    private List media;
    
    // Варианты товара
    private List variants;
    
    // Отзывы (опционально)
    private ReviewsSummaryDTO reviewsSummary;
    
    // Рекомендации стилистов (опционально)
    private List stylingRecommendations;
    
    // Хлебные крошки для навигации
    private List breadcrumbs;
}

@Data
@Builder
public class MediaDTO {
    private String type; // "image" | "video"
    private String url;
    private String webpUrl;
    private String srcSet;
    private String alt;
    private Integer sortOrder;
    private String thumbnail; // для видео
    private String hlsUrl;    // для видео
}

@Data 
@Builder
public class VariantDTO {
    private String colorName;
    private String colorHex;
    private String size;
    private Integer stockQuantity;
    private BigDecimal additionalPrice;
    private BigDecimal variantPrice;
    private Boolean isAvailable;
}
```

### 8. Безопасность и валидация

| Аспект               | Реализация                                             |
|----------------------|--------------------------------------------------------|
| **Input validation** | `@PathVariable @Positive Long id`, sanitize параметров |
| **Rate limiting**    | 100 req/min/IP для детальных страниц                   |
| **Data exposure**    | Скрыть `cost_price`, `supplier_info`, внутренние поля  |
| **CORS**             | Настроить для cross-origin запросов                    |

### 9. Мониторинг и алерты

| Метрика                          | Назначение           | Alert            |
|----------------------------------|----------------------|------------------|
| `product_detail_latency_ms`      | p95 время ответа     | > 400 ms (5 min) |
| `product_detail_cache_hit_ratio` | Эффективность кеша   | 2% (5 min)       |
| `product_detail_media_load_time` | Время загрузки медиа | > 1000 ms (p95)  |

### 10. Тестирование

| Тип             | Кейс                                                                   |
|-----------------|------------------------------------------------------------------------|
| **Unit**        | DTO mapping, URL optimization, cache key generation                    |
| **Integration** | Полная карточка со всеми связанными данными загружается за один запрос |
| **Performance** | 500 RPS на популярные товары, p95                                      |


### 11. План внедрения

1. **Создать индексы** с `CONCURRENTLY` на продакшене
2. **Расширить схему БД** полями для медиа и атрибутов
3. **Имплементировать сервис** с кэшированием и оптимизацией медиа
4. **Настроить CDN** для изображений и видео
5. **Feature flag**: A/B тест новой vs старой карточки
6. **SEO**: добавить structured data и Open Graph
7. **Мониторинг**: метрики производительности и бизнес-KPI

### 12. Риски и митигация

| Риск                                       | Митигация                                                       |
|--------------------------------------------|-----------------------------------------------------------------|
| **Большие изображения замедляют загрузку** | WebP/AVIF конвертация, responsive images, lazy loading          |
| **Много JOIN-ов в запросе**                | Денормализация часто используемых полей, материализованные view |
| **Высокая нагрузка на популярные товары**  | Агрессивное кеширование + CDN                                   |
| **404 на измененные slug**                 | 301 редирект со старых slug на новые                            |

### 13. Критерии готовности

- ✅ Полная карточка товара загружается за ≤ 200 ms (p95)
- ✅ Поддержка изображений, видео и подробных характеристик  
- ✅ Cache hit ratio > 90% для популярных товаров
- ✅ SEO-оптимизация с structured data
- ✅ Responsive медиа для разных устройств
- ✅ Интеграция с рекомендациями стилистов