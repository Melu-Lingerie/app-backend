**ML-004** - Как пользователь, я хочу быстро находить товары через поиск по названию чтобы не тратить время на просмотр всего каталога

## Постановка задачи для бэкенд-разработчика
**Тема:** «Базовый поиск товаров по названию через PostgreSQL без автодополнения и исправления ошибок»

### 1. Цель
Предоставить пользователям простой полнотекстовый поиск товаров по названию с ранжированием по релевантности, 
используя только базовые возможности PostgreSQL FTS без дополнительных функций автодополнения и коррекции.

### 2. Требования к API

| Параметр                  | Описание                                                                            |
|---------------------------|-------------------------------------------------------------------------------------|
| `GET /search`             | Единственный поисковый endpoint                                                     |
| Query-параметры           | `q` (обязательный), `page` (default 0), `limit` (≤50), стандартные фильтры каталога |
| Время ответа              | p95 ≤ 250 ms                                                                        |
| Минимальная длина запроса | 2 символа                                                                           |
| Ответ                     | `{ items, totalFound, hasMore, page, searchMeta: { query, executionTime } }`        |

### 3. Упрощенная схема БД

```sql
-- Расширения PostgreSQL
CREATE EXTENSION IF NOT EXISTS pg_trgm;

-- Добавление поискового поля (упрощенное)
ALTER TABLE products 
  ADD COLUMN search_vector tsvector GENERATED ALWAYS AS (
    setweight(to_tsvector('russian', name), 'A') ||
    setweight(to_tsvector('russian', COALESCE(description, '')), 'B')
  ) STORED;

-- Таблица статистики (опционально)
CREATE TABLE search_stats (
  id SERIAL PRIMARY KEY,
  query TEXT NOT NULL,
  results_count INT DEFAULT 0,
  search_date DATE DEFAULT CURRENT_DATE,
  search_count INT DEFAULT 1
);
```

### 4. Индексы для производительности

```sql
-- Основной GIN индекс для полнотекстового поиска
CREATE INDEX idx_products_search_vector_gin
  ON products USING GIN(search_vector);

-- Составной индекс для фильтрации + поиска
CREATE INDEX idx_products_search_active_category
  ON products (is_active, category_id)
  WHERE is_active = TRUE;

-- Индекс для статистики
CREATE INDEX idx_search_stats_query_date
  ON search_stats (query, search_date);
```

### 5. Упрощенная поисковая функция

```sql
-- Функция базового поиска без сложной логики
CREATE OR REPLACE FUNCTION basic_search_products(
  search_query TEXT,
  category_filter TEXT[] DEFAULT NULL,
  min_price NUMERIC DEFAULT NULL,
  max_price NUMERIC DEFAULT NULL,
  page_offset INT DEFAULT 0,
  page_limit INT DEFAULT 24
)
RETURNS TABLE (
  id BIGINT,
  name TEXT,
  slug TEXT,
  current_price NUMERIC,
  category_name TEXT,
  category_slug TEXT,
  main_image TEXT,
  rank REAL
) AS $$
DECLARE
  ts_query tsquery;
BEGIN
  ts_query := plainto_tsquery('russian', search_query);
  
  RETURN QUERY
  SELECT p.id,
         p.name,
         p.slug,
         COALESCE(ap.price, p.base_price) as current_price,
         c.name as category_name,
         c.slug as category_slug,
         pi.image_url as main_image,
         ts_rank_cd(p.search_vector, ts_query) as rank
    FROM products p
    JOIN categories c ON c.id = p.category_id
    LEFT JOIN (
      SELECT DISTINCT ON (product_id) product_id, price
      FROM product_prices
      ORDER BY product_id, updated_at DESC
    ) ap ON ap.product_id = p.id
    LEFT JOIN (
      SELECT DISTINCT ON (product_id) product_id, image_url
      FROM product_images
      WHERE image_type = 'main'
      ORDER BY product_id, sort_order ASC
    ) pi ON pi.product_id = p.id
   WHERE p.is_active = TRUE
     AND c.is_active = TRUE
     AND p.search_vector @@ ts_query
     AND (category_filter IS NULL OR c.slug = ANY(category_filter))
     AND (min_price IS NULL OR COALESCE(ap.price, p.base_price) >= min_price)
     AND (max_price IS NULL OR COALESCE(ap.price, p.base_price)  redisTemplate;
    
    @GetMapping
    public ResponseEntity search(
            @RequestParam @NotBlank @Size(min = 2, max = 100) String q,
            @RequestParam(defaultValue = "0") @Min(0) Integer page,
            @RequestParam(defaultValue = "24") @Max(50) Integer limit,
            @RequestParam(required = false) List categories,
            @RequestParam(required = false) BigDecimal minPrice,
            @RequestParam(required = false) BigDecimal maxPrice) {
        
        long startTime = System.currentTimeMillis();
        
        // Нормализация запроса (базовая)
        String normalizedQuery = q.trim().toLowerCase().replaceAll("\\s+", " ");
        
        // Построение кэш-ключа
        String cacheKey = buildBasicCacheKey(normalizedQuery, page, limit, 
            categories, minPrice, maxPrice);
        
        // Попытка получить из кэша
        SearchResponse cached = (SearchResponse) redisTemplate.opsForValue().get(cacheKey);
        if (cached != null) {
            meterRegistry.counter("search_cache_hit").increment();
            return ResponseEntity.ok(cached);
        }
        
        // Подготовка параметров
        Array categoriesArray = null;
        if (categories != null && !categories.isEmpty()) {
            try {
                categoriesArray = jdbcTemplate.getDataSource().getConnection()
                    .createArrayOf("text", categories.toArray());
            } catch (SQLException e) {
                log.error("Failed to create categories array", e);
                return ResponseEntity.badRequest().build();
            }
        }
        
        // Выполнение поиска
        List searchResults = jdbcTemplate.query(
            "SELECT * FROM basic_search_products(?, ?, ?, ?, ?, ?)",
            new Object[]{
                normalizedQuery,
                categoriesArray,
                minPrice,
                maxPrice,
                page * limit,
                limit
            },
            (rs, rowNum) -> ProductSearchResultDTO.builder()
                .id(rs.getLong("id"))
                .name(rs.getString("name"))
                .slug(rs.getString("slug"))
                .currentPrice(rs.getBigDecimal("current_price"))
                .categoryName(rs.getString("category_name"))
                .categorySlug(rs.getString("category_slug"))
                .mainImage(rs.getString("main_image"))
                .relevanceScore(rs.getFloat("rank"))
                .build()
        );
        
        // Подсчет общего количества результатов
        Long totalFound = getTotalSearchResults(normalizedQuery, categoriesArray, 
            minPrice, maxPrice);
        
        long executionTime = System.currentTimeMillis() - startTime;
        
        // Построение ответа
        SearchResponse response = SearchResponse.builder()
            .items(searchResults)
            .totalFound(totalFound)
            .hasMore((page + 1) * limit  0) {
            redisTemplate.opsForValue().set(cacheKey, response, 
                Duration.ofSeconds(180));
        }
        
        // Метрики
        meterRegistry.counter("search_queries_total").increment();
        meterRegistry.counter("search_results_found", 
            "has_results", String.valueOf(totalFound > 0)).increment();
        meterRegistry.timer("search_execution_time").record(executionTime, TimeUnit.MILLISECONDS);
        
        return ResponseEntity.ok()
            .cacheControl(CacheControl.maxAge(Duration.ofSeconds(120)))
            .body(response);
    }
    
    private Long getTotalSearchResults(String query, Array categories, 
            BigDecimal minPrice, BigDecimal maxPrice) {
        
        StringBuilder sql = new StringBuilder();
        sql.append("SELECT COUNT(*) FROM products p ");
        sql.append("JOIN categories c ON c.id = p.category_id ");
        sql.append("WHERE p.is_active = TRUE AND c.is_active = TRUE ");
        sql.append("AND p.search_vector @@ plainto_tsquery('russian', ?) ");
        
        List params = new ArrayList<>();
        params.add(query);
        
        if (categories != null) {
            sql.append("AND c.slug = ANY(?) ");
            params.add(categories);
        }
        
        if (minPrice != null) {
            sql.append("AND p.base_price >= ? ");
            params.add(minPrice);
        }
        
        if (maxPrice != null) {
            sql.append("AND p.base_price  categories, BigDecimal minPrice, BigDecimal maxPrice) {
        return String.format("search_basic:%s:%d:%d:%s:%s:%s",
            DigestUtils.md5Hex(query),
            page, limit,
            categories != null ? String.join(",", categories) : "null",
            minPrice != null ? minPrice.toString() : "null",
            maxPrice != null ? maxPrice.toString() : "null");
    }
}
```

### 8. Упрощенные DTO

```java
@Data
@Builder
public class SearchResponse {
    private List items;
    private Long totalFound;
    private Boolean hasMore;
    private Integer page;
    private SearchMetaDTO searchMeta;
}

@Data
@Builder
public class SearchMetaDTO {
    private String query;
    private Long executionTime; // в миллисекундах
    // Убираем: originalQuery, correctedQuery, suggestions
}

@Data
@Builder
public class ProductSearchResultDTO {
    private Long id;
    private String name;
    private String slug;
    private BigDecimal currentPrice;
    private String categoryName;
    private String categorySlug;
    private String mainImage;
    private Float relevanceScore;
}
```

### 9. Валидация и безопасность

| Аспект                  | Реализация                                         |
|-------------------------|----------------------------------------------------|
| **Input validation**    | `@NotBlank @Size(min=2, max=100)` для query        |
| **Rate limiting**       | 60 req/min/IP для поисковых запросов               |
| **SQL injection**       | Только подготовленные запросы через `JdbcTemplate` |
| **Query normalization** | Базовая очистка: trim, toLowerCase, regex          |

### 10. Мониторинг

| Метрика                     | Назначение                    | Alert            |
|-----------------------------|-------------------------------|------------------|
| `search_basic_latency_ms`   | p95 время ответа              | > 500 ms (5 min) |
| `search_zero_results_ratio` | Доля запросов без результатов | > 25% (10 min)   |
| `search_cache_hit_ratio`    | Эффективность кэша            | 1% (5 min)       |

### 11. Тестирование

| Тип             | Кейс                                                 |
|-----------------|------------------------------------------------------|
| **Unit**        | Базовая нормализация запросов, построение SQL        |
| **Integration** | FTS находит товары по точным и частичным совпадениям |
| **Performance** | 300 RPS поисковых запросов, p95 < 250 ms             |
| **Functional**  | Интеграция с фильтрами каталога работает корректно   |

### 12. PostgreSQL настройки

```sql
-- Базовые настройки для FTS
default_text_search_config = 'russian'
work_mem = '128MB'
maintenance_work_mem = '512MB'

-- Статистика
ALTER TABLE products ALTER COLUMN search_vector SET STATISTICS 500;
ANALYZE products;
```

### 13. План внедрения

1. **Создать search_vector поле** и GIN индекс с `CONCURRENTLY`
2. **Развернуть базовую функцию поиска** без сложной логики
3. **Имплементировать упрощенный endpoint** с базовым кэшированием
4. **Feature flag**: постепенное включение поиска
5. **Мониторинг**: базовые метрики производительности

### 14. Риски и митигация

| Риск                                 | Митигация                                   |
|--------------------------------------|---------------------------------------------|
| **Медленный FTS на больших объемах** | Оптимизация `work_mem`, регулярный `VACUUM` |
| **Нерелевантные результаты**         | Простое ранжирование по `ts_rank_cd`        |
| **Нагрузка на primary DB**           | Read replica для поисковых запросов         |

### 15. Критерии готовности

- ✅ Базовый FTS работает с русской морфологией, p95 < 250 ms
- ✅ Простое ранжирование по релевантности через `ts_rank_cd`
- ✅ Интеграция с существующими фильтрами каталога
- ✅ Кэширование популярных запросов
- ✅ Отсутствие автодополнения и исправления ошибок